1. Короткое резюме логики

Пользователь отправляет задачу.

(Опционально) Taskmaster улучшает промт.

Главная модель формирует основные шаги.

Модель малых шагов разбивает выбранный шаг на подзадачи (команды).

Executor выполняет команды через SSH, анализирует вывод.

При ошибке Executor делает попытки автокоррекции (локальные retries / простые изменения).

Если ошибок накопилось >= порога (например 4) по одному шагу — собираем все логи и отправляем их той самой модели, которая делала план для этого шага (т.е. модель, ответственная за уровень планирования шага), чтобы она пересмотрела план шага и предложила новый набор подзадач/альтернатив.

Цикл повторяется до успеха или явного отказа / эскалации к человеку.

2. Конфигурация (параметры, которые должны быть в config.server / config.agent)

taskmaster_enabled: true|false — включить улучшение промта.

error_threshold_per_step: 4 — сколько ошибок в рамках одного шага → эскалация.

max_retries_per_command: 2 — сколько локальных попыток автокоррекции Executor делает для одной команды.

auto_correction_enabled: true|false — разрешить автоматический фикс и повтор.

send_to_planner_after_threshold: true|false — включить отправку логов планировщику после порога.

human_escalation_threshold: N — после N полных пересмотров шага → эскалация к человеку.

forbidden_commands: [...] — список команд, которые запрещены.

dry_run_mode: true|false — опция для тестов (не выполнять, только симулировать).

3. Роли агентов (в одном месте, для ясности)

Taskmaster — улучшает/утончает пользовательский промт (опционально).

Task Agent (главный планировщик) — дробит задачу на большие шаги.

Subtask Agent / Small-step Planner — делает детализацию каждого шага в подзадачи / команды. (Именно эта модель чаще всего будет получать пересмотр при проблемах мелких шагов.)

Executor (вместе с SSH Connector) — выполняет команды, собирает stdout/stderr, считает ошибки и делает локальные автопоправки.

Error Handler / Summarizer — агрегирует ошибки, формирует отчёт и решает, пересылаем ли мы пакет логов назад в планировщик.

Human operator (опция) — получает уведомление, если автоматические механизмы не справились.

4. Подробный поток с учётом логики «4 ошибки → пересмотреть план шага»
A. Приём задачи

Пользователь формулирует задачу.

Если taskmaster_enabled=true → задача проходит через Taskmaster (улучшение промта).

Результат (улучшенный или оригинал) передаётся Task Agent.

B. Главный планировщик

Task Agent создаёт список основных шагов (Step 1, Step 2, ...).

Каждый шаг получает step_id.

C. Планирование подзадач (малые шаги)

Small-step Planner для каждого step_id генерирует последовательность подзадач/команд (subtask_id → команды).

Каждая подзадача содержит: команду, ожидаемую проверку успеха (health-check), таймаут, предусловия.

D. Выполнение Executor’ом

Executor последовательно выполняет подзадачи для текущего step_id через SSH.

Для каждой команды Executor:

Выполняет команду (или симулирует, если dry_run).

Считает exit_code, собирает stdout и stderr.

Сравнивает с ожидаемым результатом (health-check).

Если success → помечает subtask как выполненную и идёт к следующей.

Если fail → запускает автокоррекцию (если auto_correction_enabled).

E. Автокоррекция (локальная) — что делает Executor

Автокоррекция — последовательность быстрых шагов (максимум max_retries_per_command раз), например:

Проверка синтаксической ошибки в команде (например, путь не тот → исправить).

Добавить apt update перед apt install (если проблема с установкой пакета).

Попробовать альтернативный флаг (например, --no-install-recommends).

Проверить доступность сети (ping, DNS) и повторить.

Перезапустить сервис, если команда связана с сервисом.

Локальная корректировка + повтор попытки.

Каждая локальная попытка увеличивает retry_count для этой подзадачи и логируется.

F. Подсчёт ошибок на уровне шага

Для step_id ведётся счётчик error_count_step — суммарное количество неудачных подзадач (или суммарное количество фейлов после retries).

Правило: если error_count_step >= error_threshold_per_step (например 4) → триггерим эскалацию: формируем полный отчёт и отправляем его планировщику, который создавал план для этого шага (обычно это Small-step Planner; если шаг был спланирован главным планировщиком, отправить ему).

G. Формирование и отправка отчёта для пересмотра

Error Handler собирает пакет данных:

task_id, step_id, subtask_ids (все), commands (все команды шага).

Для каждой команды: command_text, stdout, stderr, exit_code, retry_count, timestamps.

Снимок состояния сервера (память/диск/запущенные сервисы/порты), если нужно.

Краткая сводка: какие предположения планировщика не подтвердились (например, пакет отсутствует в репозитории, конфликт версий, недостаточно прав).

Метаданные: конфиг сервера, ограничивающие команды, флаги безопасности.

Отправляем этот пакет в ту модель, которая делала план шага (чтобы она могла пересмотреть и предложить альтернативный набор подзадач для step_id).

H. Пересмотр плана шага

Planner (получившие логи) анализирует причины сбоев и предлагает:

Исправленный список подзадач (альтернативные команды/порядок).

Диагностические шаги (например, проверить репозиторий, установить зависимости, проверить пользователя/права).

При необходимости предлагает откат (rollback) предыдущих подзадач.

Planner возвращает обновлённый план для step_id → Executor получает новый список подзадач и запускает выполнение заново.

Логика повторяется: снова автокоррекция, подсчёт ошибок, возможная дальнейшая эскалация.

I. Ограничения и точки остановки

Если после N пересмотров шага (N — configurable, например 3) всё ещё нет успеха → эскалация к human operator (человек получает полный отчёт и предлагает ручные действия).

Также: если план пытается выполнить запрещённую команду → немедленная остановка шага и уведомление оператора.

5. Что именно отправляется в модель при эскалации (формат отчёта)

(Описание в тексте — без кода, но с чёткими полями)

Контекст задачи: короткое описание задачи и исходный промт (или улучшенный Taskmaster-версия).

step_id и текст шага (как он был запланирован).

Исходный список подзадач (включая порядок).

Полный лог выполнения: для каждой подзадачи — команда, stdout, stderr, exit_code, retry_count, timestamp.

Состояние сервера (snapshot): свободное место на диске, запущенные сервисы, сетевые ошибки (если собраны).

Конфиг: forbidden_commands, таймауты, лимиты.

Краткая сводка от Executor-а: какие гипотезы уже проверены (например, "перед установкой пакета запускали apt update 2 раза").

Чёткая просьба: "Пересмотри план шага и предложи альтернативы / дополнительную диагностику / шаги по восстановлению".

6. Примеры стратегий пересмотра плана (что может предложить planner)

Заменить установку системного пакета на установку через Docker (если системные пакеты конфликтуют).

Установить другой пакет-заместитель (альтернативное имя).

Добавить предварительные шаги: добавить репозиторий, импортировать ключ GPG, увеличить права пользователя.

Выполнить сборку из исходников вместо установки бинарного пакета.

Изменить порядок шагов, чтобы устранить конфликты зависимостей.

7. Логи, суммаризация и обратная связь пользователю

На каждом этапе пользователь получает краткие уведомления:

Начало выполнения шага.

Успех подзадачи.

Ошибка + попытка автокоррекции.

Если эскалация произошла — уведомление: "Шаг X требует пересмотра (отправили в планировщик). Ожидайте новый план или вмешательство."

После полного завершения — детальный финальный отчёт (что сделано, где были ошибки, какие решения предложены).

8. Параметры для настройки поведения (что рекомендую добавить в UI / CLI)

Переключатель Taskmaster ON/OFF.

Ползунок/поле для error_threshold_per_step.

Включение/выключение автокоррекции.

Включение/выключение автоматической пересылки логов планировщику при превышении порога.

Кнопка «Принудительно пересмотреть сейчас» для оператора (human-in-the-loop).

9. Безопасность и idempotency

Запрещённые команды проверяются до выполнения — Executor отказывает в выполнении и логирует попытку.

По возможности формировать команды идемпотентно (чтобы повтор не ломал систему).

Для критичных операций — добавлять dry-run / подтверждение человека.

10. Пример одного реального сценария (короткий)

Step 1: "Установить PostgreSQL". Small-step Planner делает:

subtask A: apt update

subtask B: apt install postgresql

subtask C: systemctl enable postgresql

subtask D: systemctl start postgresql

Executor выполняет A — OK. B — fail (exit_code=100), retry: добавил apt update и --fix-missing → retry_count=1, всё ещё fail. Попробовал альтернативный пакет (postgresql-13) → fail. (счёт ошибок для шага = 3).

После 4-й неудачной попытки (например, ещё один subtask с fail) error_count_step >= 4 → формируем отчёт и отправляем к Small-step Planner.

Planner видит, что репозиторий отсутствует на системе → предлагает: добавить репозиторий PGDG, импортировать ключ GPG, затем apt update и apt install postgresql-13. Возвращает новый план.

Executor выполняет новый план — success → шаг завершён.

11. Дополнительные рекомендации по UX / логам

Хранить историю пересмотров шага (audit trail).

В UI показывать timeline: попытки → ошибки → пересмотр плана → результат.

Возможность «просмотреть пакет логов», который отправляется в планировщик, прежде чем он будет отправлен (для отладки).